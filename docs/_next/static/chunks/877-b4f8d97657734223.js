(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[877],{5622:function(e,t,i){"use strict";i.d(t,{Pk:function(){return colorizeToken},Wq:function(){return o}});let o=[{type:"NEWLINE",re:/^\n/},{type:"WHITESPACE",re:/^( |\t)+/},{type:"COMMENT",re:/^(#.*)/},{type:"RESERVED",re:new RegExp("^(".concat("if|elif|else|in|is|while|for|pass|break|continue|def|return",")"))},{type:"NONE",re:/^None/},{type:"BOOLEAN",re:/^(True|False)/},{type:"INT",re:/^([0-9]+)/},{type:"FLOAT",re:/^([0-9]+)(\.[0-9]+)?((e|E)(\+|-)?([0-9]+))?/},{type:"STRING",re:/^(("(\\.|[^"\\])*")|('(\\.|[^'\\])*'))/},{type:"OPERATOR",re:/^(\+|-|\*|\/\/|\/|%|and|or)/},{type:"BITWISE",re:/^(<<|>>|&|\||\^)/},{type:"COMPARATOR",re:/^(<=|>=|<|>|==|!=)/},{type:"IDENTIFIER",re:/^([a-zA-Z_][a-zA-Z0-9_]*)/},{type:"ASSIGNMENT",re:/^(=|\+=|-=|\*=|\/\/=|\/=|%=|<<=|>>=|&=|\|=|\^=)/},{type:"PUNCTUATION",re:/^(\(|\)|\[|\]|\{|\}|,|:|;|\.|@)/}],l=o.reduce((e,t,i)=>{let{type:o}=t;return e[o]=i,e},{UNKNOWN:-1,EOF:-1}),r=360/o.length;function colorizeToken(e){let t=l[e];return"hsl(".concat(7*r*(t+1)%360,", 60%, 60%)")}},2553:function(e,t,i){"use strict";let o,l,r,n;function raise(e){throw Error(e)}function token(e,t){return function*(i){let r=n();void 0===r&&raise("Expected token of type ".concat(e," but stack is empty @").concat(o.iter));let[f,c]=r.split(/^([_a-zA-Z]+)(?::(.*?))?\??$/).filter(e=>e),a="?"!==r[r.length-1];if(f!==e){if(!a)return;raise("Expected token of type ".concat(e," but top of the stack is ").concat(f," @").concat(o.iter))}let s=l.tokens[o.iter];if(s.type!==t){if(!a)return;raise("Expected token of type ".concat(t," but got ").concat(s.type," @(").concat(s.line,", ").concat(s.column,")"))}if(c&&s.lexeme!==c){if(!a)return;raise("Expected ".concat(c," but got ").concat(s.lexeme," @(").concat(s.line,", ").concat(s.column,")"))}let d={name:e,attributes:{lexval:s.lexeme},children:[]};i.children.push(d),o.iter++,yield}}i.d(t,{wO:function(){return pause},hY:function(){return play},mc:function(){return logic_reset},T0:function(){return skip},Nb:function(){return step}});let f=token("newline","NEWLINE"),c=token("whitespace","WHITESPACE"),a=token("comment","COMMENT"),s=token("reserved","RESERVED"),d=token("none","NONE"),p=token("boolean","BOOLEAN"),E=token("int","INT"),y=token("float","FLOAT"),u=token("string","STRING"),I=token("operator","OPERATOR"),R=token("bitwise","BITWISE"),h=token("comparator","COMPARATOR"),k=token("identifier","IDENTIFIER"),S=token("assignment","ASSIGNMENT"),O=token("punctuation","PUNCTUATION");function*BLOCK(e){let t=n();void 0===t&&raise("Expected token of type BLOCK but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),a="?"!==f;if("BLOCK"!==i){if(!a)return;raise("Expected token of type BLOCK but top of the stack is ".concat(t," @").concat(o.iter))}let s=l.tokens[o.iter];if("EOF"===s.type){if(!a)return;raise("Expected token of type BLOCK but got $(EOF) @".concat(o.iter))}if("WHITESPACE"!==s.type){if(!a)return;raise("Expected token of type WHITESPACE but got ".concat(s.type," @").concat(o.iter))}if(s.lexeme.length<e.attributes.indent){if(!a)return;raise("Expected indentation of ".concat(e.attributes.indent," but got ").concat(s.lexeme.length," @").concat(o.iter))}let d={name:"BLOCK",attributes:{indent:e.attributes.indent},children:[]};for(let t of(e.children.push(d),r("BLOCK?"),r("STATEMENT"),r("whitespace"),yield,c(d)))yield;for(let e of STATEMENT(d))yield;for(let e of BLOCK(d))yield}function*STATEMENT(e){let t=n();void 0===t&&raise("Expected token of type STATEMENT but stack is empty @".concat(o.iter));let[i,d]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),p="?"!==d;if("STATEMENT"!==i){if(!p)return;raise("Expected token of type STATEMENT but top of the stack is ".concat(t," @").concat(o.iter))}let E={name:"STATEMENT",attributes:{indent:e.attributes.indent},children:[]};e.children.push(E);let y=l.tokens[o.iter];if("NEWLINE"===y.type)for(let e of(r("newline"),yield,f(E)))yield;else if("RESERVED"!==y.type||"if"!==y.lexeme&&"while"!==y.lexeme&&"for"!==y.lexeme&&"def"!==y.lexeme){for(let e of(r("newline"),r("comment?"),r("whitespace?"),r("SIMPLE"),yield,function*(e){let t=n();void 0===t&&raise("Expected token of type SIMPLE but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),d="?"!==f;if("SIMPLE"!==i){if(!d)return;raise("Expected token of type SIMPLE but top of the stack is ".concat(t," @").concat(o.iter))}let p={name:"SIMPLE",attributes:{},children:[]};e.children.push(p);let E=l.tokens[o.iter];if("RESERVED"===E.type){if("return"===E.lexeme){for(let e of(r("EXPRESSION"),r("whitespace"),r("reserved:return"),yield,s(p)))yield;for(let e of c(p))yield;for(let e of EXPRESSION(p))yield}else if("pass"===E.lexeme)for(let e of(r("reserved:pass"),yield,s(p)))yield;else if("break"===E.lexeme)for(let e of(r("reserved:break"),yield,s(p)))yield;else if("continue"===E.lexeme)for(let e of(r("reserved:continue"),yield,s(p)))yield;else{if(!d)return;raise("Expected token of type SIMPLE but got ".concat(E.lexeme," @").concat(o.iter))}}else if("COMMENT"===E.type)for(let e of(r("comment"),yield,a(p)))yield;else if("WHITESPACE"===E.type)for(let e of(r("whitespace"),yield,c(p)))yield;else if("IDENTIFIER"===E.type&&(o.iter+1<l.tokens.length&&"ASSIGNMENT"===l.tokens[o.iter+1].type||o.iter+2<l.tokens.length&&"ASSIGNMENT"===l.tokens[o.iter+2].type)){for(let e of(r("EXPRESSION"),r("whitespace?"),r("assignment"),r("whitespace?"),r("identifier"),yield,k(p)))yield;for(let e of c(p))yield;for(let e of S(p))yield;for(let e of c(p))yield;for(let e of EXPRESSION(p))yield}else if("IDENTIFIER"===E.type||"INT"===E.type||"FLOAT"===E.type||"STRING"===E.type||"BOOLEAN"===E.type||"NONE"===E.type||"PUNCTUATION"===E.type&&"("===E.lexeme)for(let e of(r("EXPRESSION"),yield,EXPRESSION(p)))yield;else{if(!d)return;raise("Expected token of type SIMPLE but got ".concat(E.lexeme," @").concat(o.iter))}}(E)))yield;for(let e of c(E))yield;for(let e of a(E))yield;for(let e of f(E))yield}else if("RESERVED"===y.type)for(let e of(r("COMPOUND"),yield,function*(e){let t=n();void 0===t&&raise("Expected token of type COMPOUND but stack is empty @".concat(o.iter));let[i,d]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),p="?"!==d;if("COMPOUND"!==i){if(!p)return;raise("Expected token of type COMPOUND but top of the stack is ".concat(t," @").concat(o.iter))}let E={name:"COMPOUND",attributes:{indent:e.attributes.indent+4},children:[]};e.children.push(E);let y=l.tokens[o.iter];if("if"===y.lexeme)for(let e of(r("IF"),yield,function*(e){let t=n();void 0===t&&raise("Expected token of type IF but stack is empty @".concat(o.iter));let[i,d]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e);if("IF"!==i){if("?"===d)return;raise("Expected token of type IF but top of the stack is ".concat(t," @").concat(o.iter))}let p={name:"IF",attributes:{indent:e.attributes.indent},children:[]};for(let t of(e.children.push(p),r("ELIF?"),r("BLOCK"),r("newline"),r("comment?"),r("whitespace?"),r("punctuation::"),r("whitespace?"),r("EXPRESSION"),r("whitespace"),r("reserved:if"),yield,s(p)))yield;for(let e of c(p))yield;for(let e of EXPRESSION(p))yield;for(let e of c(p))yield;for(let e of O(p))yield;for(let e of c(p))yield;for(let e of a(p))yield;for(let e of f(p))yield;for(let e of BLOCK(p))yield;for(let e of function* ELIF(e){let t=n();void 0===t&&raise("Expected token of type ELIF but stack is empty @".concat(o.iter));let[i,d]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e);if("ELIF"!==i){if("?"===d)return;raise("Expected token of type ELIF but top of the stack is ".concat(t," @").concat(o.iter))}let p={name:"ELIF",attributes:{indent:e.attributes.indent},children:[]};e.children.push(p);let E=l.tokens[o.iter];if("elif"===E.lexeme||o.iter+1<l.tokens.length&&"elif"===l.tokens[o.iter+1].lexeme){for(let e of(r("ELIF?"),r("BLOCK"),r("newline"),r("comment?"),r("whitespace?"),r("punctuation::"),r("whitespace?"),r("EXPRESSION"),r("whitespace"),r("reserved:elif"),r("whitespace?"),yield,c(p)))yield;for(let e of s(p))yield;for(let e of c(p))yield;for(let e of EXPRESSION(p))yield;for(let e of c(p))yield;for(let e of O(p))yield;for(let e of c(p))yield;for(let e of a(p))yield;for(let e of f(p))yield;for(let e of BLOCK(p))yield;for(let e of ELIF(p))yield}else for(let e of(r("ELSE?"),yield,ELSE(p)))yield}(p))yield}(E)))yield;else if("while"===y.lexeme)for(let e of(r("WHILE"),yield,function*(e){let t=n();void 0===t&&raise("Expected token of type WHILE but stack is empty @".concat(o.iter));let[i,l]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e);if("WHILE"!==i){if("?"===l)return;raise("Expected token of type WHILE but top of the stack is ".concat(t," @").concat(o.iter))}let d={name:"WHILE",attributes:{indent:e.attributes.indent},children:[]};for(let t of(e.children.push(d),r("ELSE?"),r("BLOCK"),r("newline"),r("comment?"),r("whitespace?"),r("punctuation::"),r("whitespace?"),r("EXPRESSION"),r("whitespace"),r("reserved:while"),yield,s(d)))yield;for(let e of c(d))yield;for(let e of EXPRESSION(d))yield;for(let e of c(d))yield;for(let e of O(d))yield;for(let e of c(d))yield;for(let e of a(d))yield;for(let e of f(d))yield;for(let e of BLOCK(d))yield;for(let e of ELSE(d))yield}(E)))yield;else if("for"===y.lexeme)for(let e of(r("FOR"),yield,function*(e){let t=n();void 0===t&&raise("Expected token of type FOR but stack is empty @".concat(o.iter));let[i,l]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e);if("FOR"!==i){if("?"===l)return;raise("Expected token of type FOR but top of the stack is ".concat(t," @").concat(o.iter))}let d={name:"FOR",attributes:{indent:e.attributes.indent},children:[]};for(let t of(e.children.push(d),r("ELSE?"),r("BLOCK"),r("newline"),r("comment?"),r("whitespace?"),r("punctuation::"),r("whitespace?"),r("EXPRESSION"),r("whitespace"),r("reserved:in"),r("whitespace"),r("identifier"),r("whitespace"),r("reserved:for"),yield,s(d)))yield;for(let e of c(d))yield;for(let e of k(d))yield;for(let e of c(d))yield;for(let e of s(d))yield;for(let e of c(d))yield;for(let e of EXPRESSION(d))yield;for(let e of c(d))yield;for(let e of O(d))yield;for(let e of c(d))yield;for(let e of a(d))yield;for(let e of f(d))yield;for(let e of BLOCK(d))yield;for(let e of ELSE(d))yield}(E)))yield;else if("def"===y.lexeme)for(let e of(r("FUNCTION"),yield,function*(e){let t=n();void 0===t&&raise("Expected token of type FUNCTION but stack is empty @".concat(o.iter));let[i,d]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e);if("FUNCTION"!==i){if("?"===d)return;raise("Expected token of type FUNCTION but top of the stack is ".concat(t," @").concat(o.iter))}let p={name:"FUNCTION",attributes:{indent:e.attributes.indent},children:[]};for(let t of(e.children.push(p),r("BLOCK"),r("newline"),r("comment?"),r("whitespace?"),r("punctuation::"),r("whitespace?"),r("punctuation:)"),r("whitespace?"),r("ARGS?"),r("whitespace?"),r("punctuation:("),r("whitespace?"),r("identifier"),r("whitespace"),r("reserved:def"),yield,s(p)))yield;for(let e of c(p))yield;for(let e of k(p))yield;for(let e of c(p))yield;for(let e of O(p))yield;for(let e of c(p))yield;for(let e of function*(e){let t=n();void 0===t&&raise("Expected token of type ARGS but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),a="?"!==f;if("ARGS"!==i){if(!a)return;raise("Expected token of type ARGS but top of the stack is ".concat(t," @").concat(o.iter))}if("IDENTIFIER"!==l.tokens[o.iter].type){if(!a)return;raise("Expected token of type ARGS but got ".concat(l.tokens[o.iter].lexeme," @").concat(o.iter))}let s={name:"ARGS",attributes:{},children:[]};for(let t of(e.children.push(s),r("ARGS_PRIME?"),r("identifier"),yield,k(s)))yield;for(let e of function* ARGS_PRIME(e){let t=n();void 0===t&&raise("Expected token of type ARGS_PRIME but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),a="?"!==f;if("ARGS_PRIME"!==i){if(!a)return;raise("Expected token of type ARGS_PRIME but top of the stack is ".concat(t," @").concat(o.iter))}if(","!==l.tokens[o.iter].lexeme&&(o.iter+1>=l.tokens.length||","!==l.tokens[o.iter+1].lexeme)){if(!a)return;raise("Expected token of type ARGS_PRIME but got ".concat(l.tokens[o.iter].lexeme," @").concat(o.iter))}let s={name:"ARGS_PRIME",attributes:{},children:[]};for(let t of(e.children.push(s),r("ARGS_PRIME?"),r("identifier"),r("whitespace?"),r("punctuation:,"),r("whitespace?"),yield,c(s)))yield;for(let e of O(s))yield;for(let e of c(s))yield;for(let e of k(s))yield;for(let e of ARGS_PRIME(s))yield}(s))yield}(p))yield;for(let e of c(p))yield;for(let e of O(p))yield;for(let e of c(p))yield;for(let e of O(p))yield;for(let e of c(p))yield;for(let e of a(p))yield;for(let e of f(p))yield;for(let e of BLOCK(p))yield}(E)))yield;else{if(!p)return;raise("Expected token of type COMPOUND but got ".concat(y.lexeme," @").concat(o.iter))}}(E)))yield;else{if(!p)return;raise("Expected token of type RESERVED but got ".concat(y.lexeme," @").concat(o.iter))}}function*ELSE(e){let t=n();void 0===t&&raise("Expected token of type ELSE but stack is empty @".concat(o.iter));let[i,d]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),p="?"!==d;if("ELSE"!==i){if(!p)return;raise("Expected token of type ELSE but top of the stack is ".concat(t," @").concat(o.iter))}if("else"!==l.tokens[o.iter].lexeme&&(o.iter+1>=l.tokens.length||"else"!==l.tokens[o.iter+1].lexeme)){if(!p)return;raise("Expected token of type ELSE but got ".concat(l.tokens[o.iter].lexeme," @").concat(o.iter))}let E={name:"ELSE",attributes:{indent:e.attributes.indent},children:[]};for(let t of(e.children.push(E),r("BLOCK"),r("newline"),r("comment?"),r("whitespace?"),r("punctuation::"),r("whitespace?"),r("reserved:else"),r("whitespace?"),yield,c(E)))yield;for(let e of s(E))yield;for(let e of c(E))yield;for(let e of O(E))yield;for(let e of c(E))yield;for(let e of a(E))yield;for(let e of f(E))yield;for(let e of BLOCK(E))yield}function*EXPRESSION(e){let t=n();void 0===t&&raise("Expected token of type EXPRESSION but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e);if("EXPRESSION"!==i){if("?"===f)return;raise("Expected token of type EXPRESSION but top of the stack is ".concat(t," @").concat(o.iter))}let a={name:"EXPRESSION",attributes:{},children:[]};for(let t of(e.children.push(a),r("EXPRESSION_PRIME?"),r("whitespace?"),r("COMPARISION"),yield,COMPARISION(a)))yield;for(let e of c(a))yield;for(let e of function* EXPRESSION_PRIME(e){let t=n();void 0===t&&raise("Expected token of type EXPRESSION_PRIME but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),a="?"!==f;if("EXPRESSION_PRIME"!==i){if(!a)return;raise("Expected token of type EXPRESSION_PRIME but top of the stack is ".concat(t," @").concat(o.iter))}let s=l.tokens[o.iter];if("and"!==s.lexeme&&"or"!==s.lexeme){if(!a)return;raise("Expected token of type EXPRESSION_PRIME but got ".concat(s.lexeme," @").concat(o.iter))}let d={name:"EXPRESSION_PRIME",attributes:{},children:[]};for(let t of(e.children.push(d),r("EXPRESSION_PRIME?"),r("whitespace?"),r("COMPARISION"),r("whitespace?"),"and"===s.lexeme?r("operator:and"):r("operator:or"),yield,I(d)))yield;for(let e of c(d))yield;for(let e of COMPARISION(d))yield;for(let e of c(d))yield;for(let e of EXPRESSION_PRIME(d))yield}(a))yield}function*COMPARISION(e){let t=n();void 0===t&&raise("Expected token of type COMPARISION but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e);if("COMPARISION"!==i){if("?"===f)return;raise("Expected token of type COMPARISION but top of the stack is ".concat(t," @").concat(o.iter))}let a={name:"COMPARISION",attributes:{},children:[]};for(let t of(e.children.push(a),r("COMPARISION_PRIME?"),r("whitespace?"),r("BITWISE"),yield,BITWISE(a)))yield;for(let e of c(a))yield;for(let e of function* COMPARISION_PRIME(e){let t=n();void 0===t&&raise("Expected token of type COMPARISION_PRIME but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),a="?"!==f;if("COMPARISION_PRIME"!==i){if(!a)return;raise("Expected token of type COMPARISION_PRIME but top of the stack is ".concat(t," @").concat(o.iter))}let s=l.tokens[o.iter];if("COMPARATOR"!==s.type){if(!a)return;raise("Expected token of type COMPARATOR but got ".concat(s.lexeme," @").concat(o.iter))}let d={name:"COMPARISION_PRIME",attributes:{},children:[]};if(e.children.push(d),r("COMPARISION_PRIME?"),r("whitespace?"),r("BITWISE"),r("whitespace?"),"<="===s.lexeme)r("comparator:<=");else if(">="===s.lexeme)r("comparator:>=");else if("<"===s.lexeme)r("comparator:<");else if("<"===s.lexeme)r("comparator:<");else if("=="===s.lexeme)r("comparator:==");else if("!="===s.lexeme)r("comparator:!=");else{if(!a)return;raise("Expected token of type COMPARATOR but got ".concat(s.lexeme," @").concat(o.iter))}for(let e of(yield,h(d)))yield;for(let e of c(d))yield;for(let e of BITWISE(d))yield;for(let e of c(d))yield;for(let e of COMPARISION_PRIME(d))yield}(a))yield}function*BITWISE(e){let t=n();void 0===t&&raise("Expected token of type BITWISE but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e);if("BITWISE"!==i){if("?"===f)return;raise("Expected token of type BITWISE but top of the stack is ".concat(t," @").concat(o.iter))}let a={name:"BITWISE",attributes:{},children:[]};for(let t of(e.children.push(a),r("BITWISE_PRIME?"),r("whitespace?"),r("OPERAND"),yield,OPERAND(a)))yield;for(let e of c(a))yield;for(let e of function* BITWISE_PRIME(e){let t=n();void 0===t&&raise("Expected token of type BITWISE_PRIME but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),a="?"!==f;if("BITWISE_PRIME"!==i){if(!a)return;raise("Expected token of type BITWISE_PRIME but top of the stack is ".concat(t," @").concat(o.iter))}let s=l.tokens[o.iter];if("BITWISE"!==s.type){if(!a)return;raise("Expected token of type BITWISE but got ".concat(s.lexeme," @").concat(o.iter))}let d={name:"BITWISE_PRIME",attributes:{},children:[]};if(e.children.push(d),r("BITWISE_PRIME?"),r("whitespace?"),r("OPERAND"),r("whitespace?"),"<<"===s.lexeme)r("bitwise:<<");else if(">>"===s.lexeme)r("bitwise:>>");else if("&"===s.lexeme)r("bitwise:&");else if("|"===s.lexeme)r("bitwise:|");else if("^"===s.lexeme)r("bitwise:^");else{if(!a)return;raise("Expected token of type BITWISE but got ".concat(s.lexeme," @").concat(o.iter))}for(let e of(yield,R(d)))yield;for(let e of c(d))yield;for(let e of OPERAND(d))yield;for(let e of c(d))yield;for(let e of BITWISE_PRIME(d))yield}(a))yield}function*OPERAND(e){let t=n();void 0===t&&raise("Expected token of type OPERAND but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e);if("OPERAND"!==i){if("?"===f)return;raise("Expected token of type OPERAND but top of the stack is ".concat(t," @").concat(o.iter))}let a={name:"OPERAND",attributes:{},children:[]};for(let t of(e.children.push(a),r("OPERAND_PRIME?"),r("whitespace?"),r("TERM"),yield,TERM(a)))yield;for(let e of c(a))yield;for(let e of function* OPERAND_PRIME(e){let t=n();void 0===t&&raise("Expected token of type OPERAND_PRIME but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),a="?"!==f;if("OPERAND_PRIME"!==i){if(!a)return;raise("Expected token of type OPERAND_PRIME but top of the stack is ".concat(t," @").concat(o.iter))}let s=l.tokens[o.iter];if("+"!==s.lexeme&&"-"!==s.lexeme){if(!a)return;raise("Expected token of type OPERAND_PRIME but got ".concat(s.lexeme," @").concat(o.iter))}let d={name:"OPERAND_PRIME",attributes:{},children:[]};for(let t of(e.children.push(d),r("OPERAND_PRIME?"),r("whitespace?"),r("TERM"),r("whitespace?"),"+"===s.lexeme?r("operator:+"):r("operator:-"),yield,I(d)))yield;for(let e of c(d))yield;for(let e of TERM(d))yield;for(let e of c(d))yield;for(let e of OPERAND_PRIME(d))yield}(a))yield}function*TERM(e){let t=n();void 0===t&&raise("Expected token of type TERM but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e);if("TERM"!==i){if("?"===f)return;raise("Expected token of type TERM but top of the stack is ".concat(t," @").concat(o.iter))}let a={name:"TERM",attributes:{},children:[]};for(let t of(e.children.push(a),r("TERM_PRIME?"),r("whitespace?"),r("FACTOR"),yield,FACTOR(a)))yield;for(let e of c(a))yield;for(let e of function* TERM_PRIME(e){let t=n();void 0===t&&raise("Expected token of type TERM_PRIME but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),a="?"!==f;if("TERM_PRIME"!==i){if(!a)return;raise("Expected token of type TERM_PRIME but top of the stack is ".concat(t," @").concat(o.iter))}let s=l.tokens[o.iter];if("*"!==s.lexeme&&"//"!==s.lexeme&&"/"!==s.lexeme&&"%"!==s.lexeme){if(!a)return;raise("Expected token of type TERM_PRIME but got ".concat(s.lexeme," @").concat(o.iter))}let d={name:"TERM_PRIME",attributes:{},children:[]};if(e.children.push(d),r("TERM_PRIME?"),r("whitespace?"),r("FACTOR"),r("whitespace?"),"*"===s.lexeme)r("operator:*");else if("//"===s.lexeme)r("operator://");else if("/"===s.lexeme)r("operator:/");else if("%"===s.lexeme)r("operator:%");else{if(!a)return;raise("Expected token of type TERM_PRIME but got ".concat(s.lexeme," @").concat(o.iter))}for(let e of(yield,I(d)))yield;for(let e of c(d))yield;for(let e of FACTOR(d))yield;for(let e of c(d))yield;for(let e of TERM_PRIME(d))yield}(a))yield}function*FACTOR(e){let t=n();void 0===t&&raise("Expected token of type FACTOR but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),a="?"!==f;if("FACTOR"!==i){if(!a)return;raise("Expected token of type FACTOR but top of the stack is ".concat(t," @").concat(o.iter))}let s={name:"FACTOR",attributes:{},children:[]};e.children.push(s);let I=l.tokens[o.iter];if("("===I.lexeme){for(let e of(r("punctuation:)"),r("whitespace?"),r("EXPRESSION"),r("whitespace?"),r("punctuation:("),yield,O(s)))yield;for(let e of c(s))yield;for(let e of EXPRESSION(s))yield;for(let e of c(s))yield;for(let e of O(s))yield}else if("NONE"===I.type)for(let e of(r("none"),yield,d(s)))yield;else if("BOOLEAN"===I.type)for(let e of(r("boolean"),yield,p(s)))yield;else if("INT"===I.type)for(let e of(r("int"),yield,E(s)))yield;else if("FLOAT"===I.type)for(let e of(r("float"),yield,y(s)))yield;else if("STRING"===I.type)for(let e of(r("string"),yield,u(s)))yield;else if("IDENTIFIER"===I.type){if(o.iter+1<l.tokens.length&&"("===l.tokens[o.iter+1].lexeme||o.iter+2<l.tokens.length&&"("===l.tokens[o.iter+2].lexeme)for(let e of(r("FUNCTION_CALL"),yield,function*(e){let t=n();void 0===t&&raise("Expected token of type FUNCTION_CALL but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e);if("FUNCTION_CALL"!==i){if("?"===f)return;raise("Expected token of type FUNCTION_CALL but top of the stack is ".concat(t," @").concat(o.iter))}let a={name:"FUNCTION_CALL",attributes:{},children:[]};for(let t of(e.children.push(a),r("punctuation:)"),r("whitespace?"),r("PARAMS?"),r("whitespace?"),r("punctuation:("),r("whitespace?"),r("identifier"),yield,k(a)))yield;for(let e of c(a))yield;for(let e of O(a))yield;for(let e of c(a))yield;for(let e of function*(e){let t=n();void 0===t&&raise("Expected token of type PARAMS but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),a="?"!==f;if("PARAMS"!==i){if(!a)return;raise("Expected token of type PARAMS but top of the stack is ".concat(t," @").concat(o.iter))}if("IDENTIFIER"!==l.tokens[o.iter].type&&"INT"!==l.tokens[o.iter].type&&"FLOAT"!==l.tokens[o.iter].type&&"STRING"!==l.tokens[o.iter].type&&"BOOLEAN"!==l.tokens[o.iter].type&&"NONE"!==l.tokens[o.iter].type&&("PUNCTUATION"!==l.tokens[o.iter].type||"("!==l.tokens[o.iter].lexeme)){if(!a)return;raise("Expected token of type PARAMS but got ".concat(l.tokens[o.iter].lexeme," @").concat(o.iter))}let s={name:"PARAMS",attributes:{},children:[]};for(let t of(e.children.push(s),r("PARAMS_PRIME?"),r("EXPRESSION"),yield,EXPRESSION(s)))yield;for(let e of function* PARAMS_PRIME(e){let t=n();void 0===t&&raise("Expected token of type PARAMS_PRIME but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),a="?"!==f;if("PARAMS_PRIME"!==i){if(!a)return;raise("Expected token of type PARAMS_PRIME but top of the stack is ".concat(t," @").concat(o.iter))}if(","!==l.tokens[o.iter].lexeme&&(o.iter+1>=l.tokens.length||","!==l.tokens[o.iter+1].lexeme)){if(!a)return;raise("Expected token of type PARAMS_PRIME but got ".concat(l.tokens[o.iter].lexeme," @").concat(o.iter))}let s={name:"PARAMS_PRIME",attributes:{},children:[]};for(let t of(e.children.push(s),r("PARAMS_PRIME?"),r("EXPRESSION"),r("whitespace?"),r("punctuation:,"),r("whitespace?"),yield,c(s)))yield;for(let e of O(s))yield;for(let e of c(s))yield;for(let e of EXPRESSION(s))yield;for(let e of PARAMS_PRIME(s))yield}(s))yield}(a))yield;for(let e of c(a))yield;for(let e of O(a))yield}(s)))yield;else for(let e of(r("identifier"),yield,k(s)))yield}else{if(!a)return;raise("Expected token of type FACTOR but got ".concat(I.lexeme," @").concat(o.iter))}}let m=null,N=null;function logic_reset(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:()=>{},i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:()=>{};e.iter=0,e.stack=[],e.tree=null,t(null),i(!1),pause()}function step(e,t,i,f,c,a){if(0===e.stack.length&&"EOF"===t.tokens[e.iter].type){a(!0);return}null===N&&(N=function*(e,t,i,f){for(let c of(o=e,l=t,r=i,n=f,r("START"),yield,function* START(e){let t=n();void 0===t&&raise("Expected token of type START but stack is empty @".concat(o.iter));let[i,f]=t.split(/^([_a-zA-Z]+)(\??)$/).filter(e=>e),c="?"!==f;if("START"!==i){if(!c)return;raise("Expected token of type START but top of the stack is ".concat(t," @").concat(o.iter))}let a=l.tokens[o.iter];if("EOF"===a.type){if(!c)return;raise("Expected token of type START but got $(EOF) @".concat(o.iter))}let s={name:"START",attributes:{indent:0},children:[]};for(let t of(e?e.children.push(s):o.tree=s,r("START?"),r("STATEMENT"),yield,STATEMENT(s)))yield;for(let e of START(s))yield}()))yield}(e,t,i,f));try{let{done:t}=N.next();c(e.tree),t&&(N=null,a(!0))}catch(e){N=null,a(!0),pause(),alert(e.message)}}function skip(e,t,i,o,l,r){do step(e,t,i,o,l,r);while("START"!==e.stack[e.stack.length-1]&&"START?"!==e.stack[e.stack.length-1]&&"BLOCK"!==e.stack[e.stack.length-1]&&"BLOCK?"!==e.stack[e.stack.length-1]&&"EOF"!==t.tokens[e.iter].type)}function play(e,t,i,o,l,r){m||(m=setInterval(()=>{step(e,t,i,o,l,r),0===e.stack.length&&"EOF"===t.tokens[e.iter].type&&clearInterval(m)},100))}function pause(){m&&clearInterval(m),m=null}},3677:function(e,t,i){"use strict";i.r(t),i.d(t,{default:function(){return Header}});var o=i(7437),l=i(4033),r=i(1396),n=i.n(r),f=i(2265),c=i(8910),a=i(6691),s=i.n(a),d={src:"/Python-Interpreter//_next/static/media/logo.7952cbbe.svg",height:2490,width:2500,blurWidth:0,blurHeight:0},p=i(4582),E=i.n(p);let y=[{path:"/src",name:"SRC"},{path:"/lex",name:"LEX"},{path:"/parser",name:"PARSER"},{path:"/grammar",name:"GRAMMAR"}];function Header(e){let{reset:t=()=>{},step:i=()=>{},skip:r=()=>{},play:a=()=>{},pause:p=()=>{},disabled:u=!0}=e,I=(0,l.usePathname)(),[R,h]=(0,f.useState)(!1),[k,S]=(0,f.useState)(!0),[O,m]=(0,f.useState)(!0),[N,x]=(0,f.useState)(!0),[P,A]=(0,f.useState)(!1);return(0,f.useEffect)(()=>{u?(h(!1),S(!0),m(!0),x(!0)):(h(!1),S(!1),m(!1),x(!1)),A(!1)},[u]),(0,o.jsxs)("header",{className:E().header,children:[(0,o.jsxs)(n(),{href:"/",className:E().title,children:[(0,o.jsx)(s(),{src:d,alt:"logo",width:50,height:50}),"Python Interpreter"]}),(0,o.jsx)("nav",{className:E().nav,children:(0,o.jsx)("ul",{className:E().ul,children:y.map(e=>{let{path:t,name:i}=e,l=I===t;return(0,o.jsx)("li",{className:E().li,children:(0,o.jsx)(n(),{href:t,className:l?E().active:E().link,children:i})},t)})})}),(0,o.jsxs)("ul",{className:E().ul,children:[(0,o.jsx)("li",{className:E().li,children:(0,o.jsx)("button",{title:"Reset",className:E().button,disabled:R,onClick:function(){R||t()},children:(0,o.jsx)(c.FVj,{})})}),(0,o.jsx)("li",{className:E().li,children:(0,o.jsx)("button",{title:"Step",className:E().button,disabled:k,onClick:function(){k||i()},children:(0,o.jsx)(c.Nhx,{})})}),(0,o.jsx)("li",{className:E().li,children:(0,o.jsx)("button",{title:"Skip",className:E().button,disabled:O,onClick:function(){O||r()},children:(0,o.jsx)(c.VUZ,{})})}),(0,o.jsx)("li",{className:E().li,children:(0,o.jsx)("button",{title:P?"Pause":"Play",className:E().button,disabled:N,onClick:function(){N||(P?(h(!1),S(!1),m(!1),A(!1),p()):(h(!0),S(!0),m(!0),A(!0),a()))},children:P?(0,o.jsx)(c.hPq,{}):(0,o.jsx)(c.H$B,{})})})]})]})}},16:function(e,t,i){"use strict";i.d(t,{g:function(){return l}});var o=i(2265);let l=(0,o.createContext)({iter:0,line:1,column:1,tokens:[],table:[]})},7492:function(e,t,i){"use strict";i.d(t,{h:function(){return l}});var o=i(2265);let l=(0,o.createContext)({iter:0,stack:[],tree:null})},4582:function(e){e.exports={header:"header_header__dGL52",title:"header_title__2ykLx",ul:"header_ul__PNtRg",li:"header_li__ojHv9",link:"header_link__ldUUW",active:"header_active__tsQTu",button:"header_button__1ofbi"}}}]);